/* ################################################################################
#       __  __           __    __  ___
#      / / / /___ ______/ /_  /  |/  /___ _____
#     / /_/ / __ `/ ___/ __ \/ /|_/ / __ `/ __ \
#    / __  / /_/ (__  ) / / / /  / / /_/ / /_/ /
#   /_/ /_/\__,_/____/_/ /_/_/  /_/\__,_/ .___/
#                                      /_/
#     Hash Table
#     MBITES Team
#     March 2018
#
################################################################################ */

#include <R.h>

#include "Hash-Util.h"

/* ################################################################################
 * hash_apply_c: map a function over an environment without returning values
 * call: a language object generated by match.call(expand.dots = FALSE)
 * rho: the environment in which the call was executed
################################################################################ */
SEXP hash_apply_c(SEXP call, SEXP rho){

  /* advance to 2nd element (CAR) of call pairlist; 1st element is just the hash_apply function */
  SEXP args = CDR(call);

  /* get environment (2nd element) and advance to 3rd element */
  SEXP envSymbol = install("X");
  args = CDR(args);

  /* get function (3rd element) and advance to 4th element */
  SEXP funSymbol = install("FUN");
  args = CDR(args);

  /* env is the hash table */
  SEXP env = PROTECT(eval(envSymbol,rho));
  int n = HashTableSize(HASHTAB(env), 0);

  /* get the values out of the hash table as vector/list: vals */
  SEXP vals;
  PROTECT(vals = allocVector(VECSXP,n));
  int ix = 0;
  HashTableValues(HASHTAB(env), 0, vals, &ix);

  /* make the bit of the function call that indexes over the values in the hash table */
  SEXP tmp;
  PROTECT(tmp = LCONS(R_Bracket2Symbol, LCONS(envSymbol, R_NilValue)));

  /* make the f(X[[i]],...) bit of the function call (tmp is the indexing) */
  SEXP R_fcall;
  PROTECT(R_fcall = LCONS(funSymbol, LCONS(tmp , LCONS(R_DotsSymbol,R_NilValue))));

  /* map the function(...) over the hash table */
  for(int j=0; j<n; j++){
    SETCADR(R_fcall, VECTOR_ELT(vals, j));
    R_forceAndCall(R_fcall, 1, rho);
  };

  UNPROTECT(4);
  return R_NilValue;
}

/* ################################################################################
 * hash_size_c: get the size of the hash table (number of things in it)
################################################################################ */
SEXP hash_size_c(SEXP rho){

  if(!Rf_isEnvironment(rho)){
    error("argument 'rho' passed to hash_size_c is not an environment\n");
  }

  /* env is the hash table */
  int n = HashTableSize(HASHTAB(rho), 0);

  return ScalarInteger(n);
};
